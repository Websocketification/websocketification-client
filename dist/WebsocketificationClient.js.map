{"version":3,"sources":["webpack://WebsocketificationClient/webpack/universalModuleDefinition","webpack://WebsocketificationClient/webpack/bootstrap","webpack://WebsocketificationClient/./src/Response.js","webpack://WebsocketificationClient/./src/WebsocketificationClient.js","webpack://WebsocketificationClient/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Response","_classCallCheck","this","body","status","id","NewInstance","jsonString","response","JSON","parse","setPrototypeOf","ex","WebsocketificationClient","address","_this","_ref","arguments","length","undefined","_ref$enableLogging","enableLogging","_ref$heartbeatInterva","heartbeatInterval","_ref$retryWaitingTime","retryWaitingTimeStart","_ref$retryWaitingTime2","retryWaitingTimeStep","_ref$autoDisconnectAf","autoDisconnectAfter","map","method","bind","fetch","mIsNicelyClosed","mAddress","mTempListeners","mGlobalListeners","mUnhandledListener","mEnableLogging","mOnError","event","console","error","mOnClose","mHeartbeatInterval","mHeartbeatTimeoutHandler","mRetryWaitingTimeStart","mRetryWaitingTimeStep","mRetryWaitingTime","mAutoDisconnectAfter","mAutoDisconnectionTimeoutHandler","mRequestWaitingTimeStart","mRequestWaitingTimeStep","_console","log","apply","_this2","Promise","resolve","reject","mWS","WebSocket","ws","url","onmessage","message","data","startsWith","isValid","onResponse","handleNoneRequestMessage","onopen","setupPingLoop","resetDisconnectionTimeout","onerror","onclose","onDisconnected","_this3","clearTimeout","setTimeout","readyState","OPEN","send","_this4","wasClean","connect","_this5","close","code","reason","listener","isSuccess","path","_this6","options","Math","random","Date","sendRequest","request","waitingTime","_this7","CONNECTING","stringify","CLOSING","CLOSED","Error","then","catch","callback"],"mappings":"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","file":"WebsocketificationClient.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebsocketificationClient\"] = factory();\n\telse\n\t\troot[\"WebsocketificationClient\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","'use strict';\n\n// @see https://developer.mozilla.org/en-US/docs/Web/API/Response\n// The wstf.response which is alike with fetch.response\nclass Response {\n\tconstructor() {\n\n\t}\n\n\tjson() {\n\t\treturn this.body;\n\t}\n\n\tisSuccess() {\n\t\treturn this.status >= 200 && this.status < 300 || this.status === 304;\n\t}\n\n\tisValid() {\n\t\treturn this.id && this.status;\n\t}\n}\n\nResponse.NewInstance = (jsonString) => {\n\ttry {\n\t\tconst response = JSON.parse(jsonString);\n\t\tObject.setPrototypeOf(response, Response.prototype);\n\t\treturn response;\n\t} catch (ex) {\n\t\t// Ignore the exception.\n\t}\n};\n\nmodule.exports = Response;","'use strict';\n\n// @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n// @see https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications\n\nconst Response = require('./Response');\n\n// Defined commands.\nconst CMD_PREFIX = '$';\nconst CMD_PING = '$PING';\nconst CMD_PONG = '$PONG';\n\nconst JSON_OBJECT_PREFIX = '{';\n\nconst METHOD_DEFAULT = 'GET';\n\nclass WebsocketificationClient {\n\tconstructor(address, {\n\t\tenableLogging = true,\n\t\t// Heartbeat interval in milliseconds, default: send '$PING' every 50 seconds.\n\t\theartbeatInterval = 50000,\n\t\tretryWaitingTimeStart = 0,\n\t\tretryWaitingTimeStep = 230,\n\t\t// Disconnect after milliseconds with no activities.\n\t\t// Default value is 35 minutes, and set to 0 to disable auto disconnection.\n\t\tautoDisconnectAfter = 35 * 60000,\n\t} = {}) {\n\t\t[\n\t\t\t'connect', 'close',\n\t\t\t'onResponse',\n\t\t\t'fetch',\n\t\t\t'setOnBroadcastListener', 'setOnUnhandledResponseListener',\n\t\t\t'setOnClosedListener', 'setOnErrorListener'\n\t\t].map(method => this[method] = this[method].bind(this));\n\t\tthis.fetch = this.fetch.bind(this);\n\t\t// Whether the socket is closed nicely, if the socket is closed or closing.\n\t\tthis.mIsNicelyClosed = true;\n\t\tthis.mAddress = address;\n\t\t/**\n\t\t * Temp listener that will be triggered only for once.\n\t\t */\n\t\tthis.mTempListeners = [];\n\t\t/**\n\t\t * Global listener that will be triggered more than once.\n\t\t */\n\t\tthis.mGlobalListeners = [];\n\t\t/**\n\t\t * Unhandled listener that will be called for unhandled response.\n\t\t */\n\t\tthis.mUnhandledListener = undefined;\n\t\tthis.mEnableLogging = enableLogging;\n\t\tif (this.mEnableLogging) {\n\t\t\t// The default WebSocket.onerror event listener.\n\t\t\tthis.mOnError = (event) => console.error('WebSocket onerror callback triggered: ws.onerror(event)->', event);\n\t\t\t// The default WebSocket.onclose event listener.\n\t\t\tthis.mOnClose = null;\n\t\t}\n\n\t\t// Configure for heartbeat package.\n\t\tthis.mHeartbeatInterval = heartbeatInterval;\n\t\tthis.mHeartbeatTimeoutHandler = null;\n\n\t\t// Waiting time for retry.\n\t\tthis.mRetryWaitingTimeStart = retryWaitingTimeStart;\n\t\tthis.mRetryWaitingTimeStep = retryWaitingTimeStep;\n\t\tthis.mRetryWaitingTime = this.mRetryWaitingTimeStart;\n\n\t\t// Auto disconnection policy.\n\t\tthis.mAutoDisconnectAfter = autoDisconnectAfter;\n\t\tthis.mAutoDisconnectionTimeoutHandler = null;\n\n\t\t// Waiting time for CONNECTING => CONNECTED.\n\t\tthis.mRequestWaitingTimeStart = 100;\n\t\tthis.mRequestWaitingTimeStep = 20;\n\t}\n\n\tlog(...args) {\n\t\tif (this.mEnableLogging) {\n\t\t\tconsole.log(...args);\n\t\t}\n\t}\n\n\tconnect() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tthis.mWS = new WebSocket(this.mAddress);\n\t\t\t} catch (ex) {\n\t\t\t\treject(ex, 'Invalid address: ' + address);\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst ws = this.mWS;\n\t\t\tthis.log(`Connecting to ${ws.url}.`);\n\t\t\tws.onmessage = (message) => {\n\t\t\t\t// Skip if, obviously, not an json object is received.\n\t\t\t\tif (!message.data.startsWith(JSON_OBJECT_PREFIX)) {\n\t\t\t\t\tthis.handleNoneRequestMessage(message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst response = Response.NewInstance(message.data);\n\t\t\t\tif (!response) {\n\t\t\t\t\tthis.log('Unexpected response data:', message.data);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!response.isValid()) {\n\t\t\t\t\tthis.log('Invalid response(fields of id and status are required):', response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.onResponse(response);\n\t\t\t};\n\t\t\tws.onopen = (event) => {\n\t\t\t\tthis.log(`Connected to ${ws.url}.`);\n\t\t\t\tthis.setupPingLoop();\n\t\t\t\tthis.resetDisconnectionTimeout();\n\t\t\t\t// Reset the retry waiting time.\n\t\t\t\tthis.mRetryWaitingTime = this.mRetryWaitingTimeStart;\n\t\t\t\tresolve(event);\n\t\t\t};\n\t\t\tws.onerror = (event) => {\n\t\t\t\tif (this.mOnError) {\n\t\t\t\t\tthis.mOnError(event);\n\t\t\t\t}\n\t\t\t\treject(event);\n\t\t\t};\n\t\t\tws.onclose = (event) => {\n\t\t\t\tthis.onDisconnected(event);\n\t\t\t\tif (this.mOnClose) {\n\t\t\t\t\tthis.mOnClose(event);\n\t\t\t\t}\n\t\t\t\treject(event);\n\t\t\t};\n\t\t})\n\t}\n\n\tsetupPingLoop() {\n\t\tif (this.mHeartbeatInterval <= 0) {return;}\n\t\t// Ping in intervals.\n\t\tif (this.mHeartbeatTimeoutHandler) {clearTimeout(this.mHeartbeatTimeoutHandler);}\n\t\tthis.mHeartbeatTimeoutHandler = setTimeout(() => {\n\t\t\tif (this.mWS.readyState !== WebSocket.OPEN) {return;}\n\t\t\tthis.mWS.send(CMD_PING);\n\t\t\tthis.setupPingLoop();\n\t\t}, this.mHeartbeatInterval);\n\t}\n\n\thandleNoneRequestMessage(message) {\n\t\t// Skip if any internal command is received.\n\t\tif (message.data.startsWith(CMD_PREFIX)) {\n\t\t\tswitch (message.data) {\n\t\t\t\tcase CMD_PING:\n\t\t\t\t\tthis.mWS.send(CMD_PONG);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMD_PONG:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tonDisconnected(event) {\n\t\tif (event.wasClean) {\n\t\t\t// Connection is elegantly closed.\n\t\t\tthis.mIsNicelyClosed = true;\n\t\t\tthis.log(`WebSocket disconnected nicely, by client or server, and auto reconnection will be triggered when any message is needed to be sent.`);\n\t\t\treturn;\n\t\t}\n\t\tthis.mIsNicelyClosed = false;\n\t\tif (this.mRetryWaitingTime + this.mRetryWaitingTimeStep <= 0) {\n\t\t\tthis.log('WebSocket disconnected abnormally and no auto reconnection is scheduled due to configuration.');\n\t\t\treturn;\n\t\t}\n\t\tthis.log(`WebSocket disconnected abnormally and auto reconnection is scheduled after ${this.mRetryWaitingTime} milliseconds.`);\n\t\t// Schedule an auto reconnection.\n\t\tsetTimeout(() => {\n\t\t\tthis.connect();\n\t\t\tthis.mRetryWaitingTime += this.mRetryWaitingTimeStep;\n\t\t}, this.mRetryWaitingTime);\n\t}\n\n\t// Update auto disconnection timeout handler, will be called every time when after ws.onopen(), and before ws.send().\n\tresetDisconnectionTimeout() {\n\t\tif (this.mAutoDisconnectAfter <= 0) {return;}\n\t\tif (this.mAutoDisconnectionTimeoutHandler) {clearTimeout(this.mAutoDisconnectionTimeoutHandler)}\n\t\tthis.mAutoDisconnectionTimeoutHandler = setTimeout(() => {\n\t\t\tif (this.mWS.readyState === WebSocket.OPEN) {this.mWS.close(1000);}\n\t\t}, this.mAutoDisconnectAfter);\n\t}\n\n\t/**\n\t * Close connection.\n\t */\n\tclose(code = 1000, reason) {\n\t\tthis.mWS.close(code, reason);\n\t}\n\n\t/**\n\t * Handle response.\n\t */\n\tonResponse(response) {\n\t\tlet listener = this.mTempListeners[response.id];\n\t\tif (listener) {\n\t\t\tdelete this.mTempListeners[response.id];\n\t\t\tif (response.isSuccess()) {\n\t\t\t\tlistener.resolve(response);\n\t\t\t} else {\n\t\t\t\tlistener.reject(response);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlistener = this.mGlobalListeners[response.id];\n\t\tif (listener) {\n\t\t\tif (response.isSuccess()) {\n\t\t\t\tlistener(null, response);\n\t\t\t} else {\n\t\t\t\tlistener(response);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (this.mUnhandledListener) {\n\t\t\tthis.mUnhandledListener(response);\n\t\t}\n\t}\n\n\t/**\n\t * Fetch resources like HTTP request.\n\t *\n\t * @param path Resource path.\n\t * @param options\n\t * @returns {Promise}\n\t */\n\tfetch(path, options = {}) {\n\t\tthis.resetDisconnectionTimeout();\n\t\toptions.path = path;\n\t\toptions.id = `http$${Math.random()}@${+new Date()}`;\n\t\tif (!options.method) {options.method = METHOD_DEFAULT;}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.sendRequest(resolve, reject, options, this.mRequestWaitingTimeStart);\n\t\t});\n\t}\n\n\tsendRequest(resolve, reject, request, waitingTime) {\n\t\tif (this.mWS.readyState === WebSocket.CONNECTING) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.sendRequest(resolve, reject, request, waitingTime);\n\t\t\t}, waitingTime);\n\t\t\t// Slow down the loop.\n\t\t\twaitingTime += this.mRequestWaitingTimeStep;\n\t\t} else if (this.mWS.readyState === WebSocket.OPEN) {\n\t\t\tthis.mWS.send(JSON.stringify(request));\n\t\t\t// Set listener.\n\t\t\tthis.mTempListeners[request.id] = {resolve, reject};\n\t\t} else if (this.mWS.readyState === WebSocket.CLOSING || this.mWS.readyState === WebSocket.CLOSED) {\n\t\t\tif (!this.mIsNicelyClosed) {\n\t\t\t\t// Reject error immediately if the WebSocket is closed abnormally.\n\t\t\t\treject(new Error('WebSocket is closed abnormally and is trying to reconnect:' + this.mWS.readyState));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Reconnect now if the WebSocket is closed normally.\n\t\t\tthis.connect().then(() => {\n\t\t\t\tif (this.mWS.readyState !== WebSocket.OPEN) {\n\t\t\t\t\t// This is not going to happen.\n\t\t\t\t\treject(new Error('WebSocket should be open: ' + WebSocket.readyState));\n\t\t\t\t}\n\t\t\t\tthis.mWS.send(JSON.stringify(request));\n\t\t\t\t// Set listener.\n\t\t\t\tthis.mTempListeners[request.id] = {resolve, reject};\n\t\t\t}).catch((ex) => {\n\t\t\t\treject(ex);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Set on broadcast listener.\n\t *\n\t * @param id{String} Broadcast id, which is usually a path.\n\t * @param callback{Function} Callback.\n\t */\n\tsetOnBroadcastListener(id, callback) {\n\t\tthis.mGlobalListeners[id] = callback;\n\t}\n\n\t/**\n\t * Set unhandled listener.\n\t * @param callback{Function} Callback.\n\t */\n\tsetOnUnhandledResponseListener(callback) {\n\t\tthis.mUnhandledListener = callback;\n\t}\n\n\t/**\n\t * Set on closed listener.\n\t *\n\t * Pass null to remove listener.\n\t * @param callback Callback.\n\t */\n\tsetOnClosedListener(callback) {\n\t\tthis.mOnClose = callback;\n\t}\n\n\t/**\n\t * Set on error listener.\n\t *\n\t * Pass null to remove listener.\n\t * @param callback Callback.\n\t */\n\tsetOnErrorListener(callback) {\n\t\tthis.mOnError = callback;\n\t}\n}\n\nmodule.exports = WebsocketificationClient;\n","'use strict';\n\nmodule.exports = require('./WebsocketificationClient');\n"],"sourceRoot":""}