{"version":3,"sources":["webpack://WebsocketificationClient/webpack/universalModuleDefinition","webpack://WebsocketificationClient/webpack/bootstrap","webpack://WebsocketificationClient/./src/Response.js","webpack://WebsocketificationClient/./src/WebsocketificationClient.js","webpack://WebsocketificationClient/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Response","_classCallCheck","this","body","status","id","NewInstance","jsonString","response","JSON","parse","setPrototypeOf","ex","WebsocketificationClient","address","_this","_ref","arguments","length","undefined","_ref$enableLogging","enableLogging","_ref$heartbeatInterva","heartbeatInterval","_ref$retryWaitingTime","retryWaitingTimeStart","_ref$retryWaitingTime2","retryWaitingTimeStep","_ref$autoDisconnectAf","autoDisconnectAfter","map","method","bind","fetch","mIsManualDisconnected","mManualDisconnectionResolveFunc","mIsNicelyClosed","mAddress","mTempListeners","mGlobalListeners","mUnhandledListener","mEnableLogging","mOnError","event","console","error","mOnClose","mHeartbeatInterval","mHeartbeatTimeoutHandler","mRetryWaitingTimeStart","mRetryWaitingTimeStep","mRetryWaitingTime","mAutoDisconnectAfter","mAutoDisconnectionTimeoutHandler","mRequestWaitingTimeStart","mRequestWaitingTimeStep","_console","log","apply","_this2","Promise","resolve","reject","mWS","WebSocket","ws","url","onmessage","message","data","startsWith","isValid","onResponse","handleNoneRequestMessage","onopen","setupPingLoop","resetDisconnectionTimeout","onerror","onclose","onDisconnected","_this3","clearTimeout","setTimeout","readyState","OPEN","send","_this4","wasClean","connect","_this5","close","_this6","code","reason","_this7","finally","then","catch","listener","isSuccess","path","_this8","options","Math","random","Date","sendRequest","request","waitingTime","_this9","CONNECTING","stringify","CLOSING","CLOSED","Error","callback"],"mappings":"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","file":"WebsocketificationClient.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebsocketificationClient\"] = factory();\n\telse\n\t\troot[\"WebsocketificationClient\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","'use strict';\n\n// @see https://developer.mozilla.org/en-US/docs/Web/API/Response\n// The wstf.response which is alike with fetch.response\nclass Response {\n\tconstructor() {\n\n\t}\n\n\tjson() {\n\t\treturn this.body;\n\t}\n\n\tisSuccess() {\n\t\treturn this.status >= 200 && this.status < 300 || this.status === 304;\n\t}\n\n\tisValid() {\n\t\treturn this.id && this.status;\n\t}\n}\n\nResponse.NewInstance = (jsonString) => {\n\ttry {\n\t\tconst response = JSON.parse(jsonString);\n\t\tObject.setPrototypeOf(response, Response.prototype);\n\t\treturn response;\n\t} catch (ex) {\n\t\t// Ignore the exception.\n\t}\n};\n\nmodule.exports = Response;","'use strict';\n\n// @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n// @see https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications\n\nconst Response = require('./Response');\n\n// Defined commands.\nconst CMD_PREFIX = '$';\nconst CMD_PING = '$PING';\nconst CMD_PONG = '$PONG';\n\nconst JSON_OBJECT_PREFIX = '{';\n\nconst METHOD_DEFAULT = 'GET';\n\nclass WebsocketificationClient {\n\tconstructor(address, {\n\t\tenableLogging = true,\n\t\t// Heartbeat interval in milliseconds, default: send '$PING' every 50 seconds.\n\t\theartbeatInterval = 50000,\n\t\tretryWaitingTimeStart = 0,\n\t\tretryWaitingTimeStep = 230,\n\t\t// Disconnect after milliseconds with no activities.\n\t\t// Default value is 35 minutes, and set to 0 to disable auto disconnection.\n\t\tautoDisconnectAfter = 35 * 60000,\n\t} = {}) {\n\t\t[\n\t\t\t'connect', 'close',\n\t\t\t'onResponse',\n\t\t\t'fetch',\n\t\t\t'setOnBroadcastListener', 'setOnUnhandledResponseListener',\n\t\t\t'setOnClosedListener', 'setOnErrorListener'\n\t\t].map(method => this[method] = this[method].bind(this));\n\t\tthis.fetch = this.fetch.bind(this);\n\n\t\t/* Manual Disconnection */\n\t\tthis.mIsManualDisconnected = false;\n\t\tthis.mManualDisconnectionResolveFunc = null;\n\n\t\t// Whether the socket is closed nicely, if the socket is closed or closing.\n\t\tthis.mIsNicelyClosed = true;\n\t\tthis.mAddress = address;\n\t\t/**\n\t\t * Temp listener that will be triggered only for once.\n\t\t */\n\t\tthis.mTempListeners = [];\n\t\t/**\n\t\t * Global listener that will be triggered more than once.\n\t\t */\n\t\tthis.mGlobalListeners = [];\n\t\t/**\n\t\t * Unhandled listener that will be called for unhandled response.\n\t\t */\n\t\tthis.mUnhandledListener = undefined;\n\t\tthis.mEnableLogging = enableLogging;\n\t\tif (this.mEnableLogging) {\n\t\t\t// The default WebSocket.onerror event listener.\n\t\t\tthis.mOnError = (event) => console.error('WebSocket onerror callback triggered: ws.onerror(event)->', event);\n\t\t\t// The default WebSocket.onclose event listener.\n\t\t\tthis.mOnClose = null;\n\t\t}\n\n\t\t// Configure for heartbeat package.\n\t\tthis.mHeartbeatInterval = heartbeatInterval;\n\t\tthis.mHeartbeatTimeoutHandler = null;\n\n\t\t// Waiting time for retry.\n\t\tthis.mRetryWaitingTimeStart = retryWaitingTimeStart;\n\t\tthis.mRetryWaitingTimeStep = retryWaitingTimeStep;\n\t\tthis.mRetryWaitingTime = this.mRetryWaitingTimeStart;\n\n\t\t// Auto disconnection policy.\n\t\tthis.mAutoDisconnectAfter = autoDisconnectAfter;\n\t\tthis.mAutoDisconnectionTimeoutHandler = null;\n\n\t\t// Waiting time for CONNECTING => CONNECTED.\n\t\tthis.mRequestWaitingTimeStart = 100;\n\t\tthis.mRequestWaitingTimeStep = 20;\n\t}\n\n\tlog(...args) {\n\t\tif (this.mEnableLogging) {\n\t\t\tconsole.log(...args);\n\t\t}\n\t}\n\n\tconnect() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tthis.mWS = new WebSocket(this.mAddress);\n\t\t\t} catch (ex) {\n\t\t\t\treject(ex, 'Invalid address: ' + address);\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst ws = this.mWS;\n\t\t\tthis.log(`Connecting to ${ws.url}.`);\n\t\t\tws.onmessage = (message) => {\n\t\t\t\t// Skip if, obviously, not an json object is received.\n\t\t\t\tif (!message.data.startsWith(JSON_OBJECT_PREFIX)) {\n\t\t\t\t\tthis.handleNoneRequestMessage(message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst response = Response.NewInstance(message.data);\n\t\t\t\tif (!response) {\n\t\t\t\t\tthis.log('Unexpected response data:', message.data);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!response.isValid()) {\n\t\t\t\t\tthis.log('Invalid response(fields of id and status are required):', response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.onResponse(response);\n\t\t\t};\n\t\t\tws.onopen = (event) => {\n\t\t\t\tthis.log(`Connected to ${ws.url}.`);\n\t\t\t\tthis.setupPingLoop();\n\t\t\t\tthis.resetDisconnectionTimeout();\n\t\t\t\t// Reset the retry waiting time.\n\t\t\t\tthis.mRetryWaitingTime = this.mRetryWaitingTimeStart;\n\t\t\t\tresolve(event);\n\t\t\t};\n\t\t\tws.onerror = (event) => {\n\t\t\t\tif (this.mOnError) {\n\t\t\t\t\tthis.mOnError(event);\n\t\t\t\t}\n\t\t\t\treject(event);\n\t\t\t};\n\t\t\tws.onclose = (event) => {\n\t\t\t\tthis.onDisconnected(event);\n\t\t\t\tif (this.mOnClose) {\n\t\t\t\t\tthis.mOnClose(event);\n\t\t\t\t}\n\t\t\t\treject(event);\n\t\t\t};\n\t\t})\n\t}\n\n\tsetupPingLoop() {\n\t\tif (this.mHeartbeatInterval <= 0) {return;}\n\t\t// Ping in intervals.\n\t\tif (this.mHeartbeatTimeoutHandler) {clearTimeout(this.mHeartbeatTimeoutHandler);}\n\t\tthis.mHeartbeatTimeoutHandler = setTimeout(() => {\n\t\t\tif (this.mWS.readyState !== WebSocket.OPEN) {return;}\n\t\t\tthis.mWS.send(CMD_PING);\n\t\t\tthis.setupPingLoop();\n\t\t}, this.mHeartbeatInterval);\n\t}\n\n\thandleNoneRequestMessage(message) {\n\t\t// Skip if any internal command is received.\n\t\tif (message.data.startsWith(CMD_PREFIX)) {\n\t\t\tswitch (message.data) {\n\t\t\t\tcase CMD_PING:\n\t\t\t\t\tthis.mWS.send(CMD_PONG);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMD_PONG:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tonDisconnected(event) {\n\t\tif (this.mIsManualDisconnected && this.mManualDisconnectionResolveFunc) {\n\t\t\tthis.mIsManualDisconnected = false;\n\t\t\t// Successfully manually disconnected.\n\t\t\tthis.mManualDisconnectionResolveFunc(event);\n\t\t\tthis.mManualDisconnectionResolveFunc = null;\n\t\t}\n\t\tif (event.wasClean) {\n\t\t\t// Connection is elegantly closed.\n\t\t\tthis.mIsNicelyClosed = true;\n\t\t\tthis.log(`WebSocket disconnected nicely, by client or server, and auto reconnection will be triggered when any message is needed to be sent.`);\n\t\t\treturn;\n\t\t}\n\t\tthis.mIsNicelyClosed = false;\n\t\tif (this.mRetryWaitingTime + this.mRetryWaitingTimeStep <= 0) {\n\t\t\tthis.log('WebSocket disconnected abnormally and no auto reconnection is scheduled due to configuration.');\n\t\t\treturn;\n\t\t}\n\t\tthis.log(`WebSocket disconnected abnormally and auto reconnection is scheduled after ${this.mRetryWaitingTime} milliseconds.`);\n\t\t// Schedule an auto reconnection.\n\t\tsetTimeout(() => {\n\t\t\tthis.connect();\n\t\t\tthis.mRetryWaitingTime += this.mRetryWaitingTimeStep;\n\t\t}, this.mRetryWaitingTime);\n\t}\n\n\t// Update auto disconnection timeout handler, will be called every time when after ws.onopen(), and before ws.send().\n\tresetDisconnectionTimeout() {\n\t\tif (this.mAutoDisconnectAfter <= 0) {return;}\n\t\tif (this.mAutoDisconnectionTimeoutHandler) {clearTimeout(this.mAutoDisconnectionTimeoutHandler)}\n\t\tthis.mAutoDisconnectionTimeoutHandler = setTimeout(() => {\n\t\t\tif (this.mWS.readyState === WebSocket.OPEN) {this.mWS.close(1000);}\n\t\t}, this.mAutoDisconnectAfter);\n\t}\n\n\t/**\n\t * Close connection.\n\t */\n\tclose(code = 1000, reason) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this.mWS.readyState === WebSocket.OPEN) {\n\t\t\t\tthis.mIsManualDisconnected = true;\n\t\t\t\tthis.mManualDisconnectionResolveFunc = resolve;\n\t\t\t\tthis.mWS.close(code, reason);\n\t\t\t} else {\n\t\t\t\treject('The WebSocket is not opening, and hence cannot be close!');\n\t\t\t}\n\t\t});\n\t}\n\n\t// Reconnect to the WebSocket server.\n\treconnect(code = 1000) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.close(code).finally(() => {\n\t\t\t\tthis.log(`WebSocket disconnected manually by client and a reconnection is scheduled since this.reconnect() is called!`);\n\t\t\t\tthis.connect().then(resolve).catch(reject);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Handle response.\n\t */\n\tonResponse(response) {\n\t\tlet listener = this.mTempListeners[response.id];\n\t\tif (listener) {\n\t\t\tdelete this.mTempListeners[response.id];\n\t\t\tif (response.isSuccess()) {\n\t\t\t\tlistener.resolve(response);\n\t\t\t} else {\n\t\t\t\tlistener.reject(response);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlistener = this.mGlobalListeners[response.id];\n\t\tif (listener) {\n\t\t\tif (response.isSuccess()) {\n\t\t\t\tlistener(null, response);\n\t\t\t} else {\n\t\t\t\tlistener(response);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (this.mUnhandledListener) {\n\t\t\tthis.mUnhandledListener(response);\n\t\t}\n\t}\n\n\t/**\n\t * Fetch resources like HTTP request.\n\t *\n\t * @param path Resource path.\n\t * @param options\n\t * @returns {Promise}\n\t */\n\tfetch(path, options = {}) {\n\t\tthis.resetDisconnectionTimeout();\n\t\toptions.path = path;\n\t\toptions.id = `http$${Math.random()}@${+new Date()}`;\n\t\tif (!options.method) {options.method = METHOD_DEFAULT;}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.sendRequest(resolve, reject, options, this.mRequestWaitingTimeStart);\n\t\t});\n\t}\n\n\tsendRequest(resolve, reject, request, waitingTime) {\n\t\tif (this.mWS.readyState === WebSocket.CONNECTING) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.sendRequest(resolve, reject, request, waitingTime);\n\t\t\t}, waitingTime);\n\t\t\t// Slow down the loop.\n\t\t\twaitingTime += this.mRequestWaitingTimeStep;\n\t\t} else if (this.mWS.readyState === WebSocket.OPEN) {\n\t\t\tthis.mWS.send(JSON.stringify(request));\n\t\t\t// Set listener.\n\t\t\tthis.mTempListeners[request.id] = {resolve, reject};\n\t\t} else if (this.mWS.readyState === WebSocket.CLOSING || this.mWS.readyState === WebSocket.CLOSED) {\n\t\t\tif (!this.mIsNicelyClosed) {\n\t\t\t\t// Reject error immediately if the WebSocket is closed abnormally.\n\t\t\t\treject(new Error('WebSocket is closed abnormally and is trying to reconnect:' + this.mWS.readyState));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Reconnect now if the WebSocket is closed normally.\n\t\t\tthis.connect().then(() => {\n\t\t\t\tif (this.mWS.readyState !== WebSocket.OPEN) {\n\t\t\t\t\t// This is not going to happen.\n\t\t\t\t\treject(new Error('WebSocket should be open: ' + WebSocket.readyState));\n\t\t\t\t}\n\t\t\t\tthis.mWS.send(JSON.stringify(request));\n\t\t\t\t// Set listener.\n\t\t\t\tthis.mTempListeners[request.id] = {resolve, reject};\n\t\t\t}).catch((ex) => {\n\t\t\t\treject(ex);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Set on broadcast listener.\n\t *\n\t * @param id{String} Broadcast id, which is usually a path.\n\t * @param callback{Function} Callback.\n\t */\n\tsetOnBroadcastListener(id, callback) {\n\t\tthis.mGlobalListeners[id] = callback;\n\t}\n\n\t/**\n\t * Set unhandled listener.\n\t * @param callback{Function} Callback.\n\t */\n\tsetOnUnhandledResponseListener(callback) {\n\t\tthis.mUnhandledListener = callback;\n\t}\n\n\t/**\n\t * Set on closed listener.\n\t *\n\t * Pass null to remove listener.\n\t * @param callback Callback.\n\t */\n\tsetOnClosedListener(callback) {\n\t\tthis.mOnClose = callback;\n\t}\n\n\t/**\n\t * Set on error listener.\n\t *\n\t * Pass null to remove listener.\n\t * @param callback Callback.\n\t */\n\tsetOnErrorListener(callback) {\n\t\tthis.mOnError = callback;\n\t}\n}\n\nmodule.exports = WebsocketificationClient;\n","'use strict';\n\nmodule.exports = require('./WebsocketificationClient');\n"],"sourceRoot":""}